{
    "language": "Solidity",
    "sources": {
        "contracts/UnibitDex.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./IERC20.sol\";\n\nstruct TokenLiquidity {\n    uint ethPool;\n    uint tokenPool;\n}\n\ncontract UnibitDex is Ownable {\n\n    mapping(address => TokenLiquidity) public tokenLiquidity;\n    mapping(address => address) public tokenPoolOwner;\n    mapping(address => address[]) public ownerTokenPools;\n    address[] public tokens;\n    uint public DEX_FEE;\n    address public DEX_FEE_DESTINATION_ADDRESS;\n\n    constructor() Ownable(msg.sender) {\n        DEX_FEE = 3;\n        DEX_FEE_DESTINATION_ADDRESS = msg.sender;\n    }\n\n    function createOrAddLiquidity(address _tokenAddress, uint _tokenPool) external payable {\n        require(IERC20(_tokenAddress).transferFrom(msg.sender, address(this), _tokenPool), \"Failed transfer from token.\");\n        if (tokenPoolOwner[_tokenAddress] == address(0)) { // CREATE LIQUIDITY\n            tokenLiquidity[_tokenAddress] = TokenLiquidity(msg.value, _tokenPool);\n            tokenPoolOwner[_tokenAddress] = msg.sender;\n            ownerTokenPools[msg.sender].push(_tokenAddress);\n            tokens.push(_tokenAddress);\n        } else { // ADD LIQUIDITY\n            tokenLiquidity[_tokenAddress].ethPool += msg.value;\n            tokenLiquidity[_tokenAddress].tokenPool += _tokenPool;\n        }\n    }\n    \n    function removeTokenLiquidity(address _tokenAddress, uint _tokenPool, uint _ethPool) external {\n        require(tokenPoolOwner[_tokenAddress] == msg.sender, \"Only pool owner can remove liquidity\");\n        require(_tokenPool <= tokenLiquidity[_tokenAddress].tokenPool, \"Exceeds the liquidity balance\");\n        require(_ethPool <= tokenLiquidity[_tokenAddress].ethPool, \"Exceeds the liquidity balance\");\n        IERC20(_tokenAddress).transfer(msg.sender, _tokenPool);\n        payable(msg.sender).transfer(_ethPool);\n        tokenLiquidity[_tokenAddress].tokenPool -= _tokenPool;\n        tokenLiquidity[_tokenAddress].ethPool -= _ethPool;\n    }\n\n    function swapTokenToEth(address _tokenAddress, uint _tokenQuantity) external {\n        require(tokenPoolOwner[_tokenAddress] != address(0), \"Token is not created.\");\n        uint _tokenValue = getTokenValue(_tokenAddress);\n        TokenLiquidity memory _tokenLiquidity = tokenLiquidity[_tokenAddress];\n        uint dec = 10 ** 18;\n        uint _ethToSwap = _tokenQuantity * _tokenValue / dec;\n        require(_ethToSwap <= _tokenLiquidity.ethPool, \"Exceeds the liquidity balance\");\n        require(IERC20(_tokenAddress).transferFrom(msg.sender, address(this), _tokenQuantity), \"Failed transfer from token.\");\n        uint fee = _ethToSwap * DEX_FEE / 1000;\n        payable(msg.sender).transfer(_ethToSwap - fee);\n        payable(DEX_FEE_DESTINATION_ADDRESS).transfer(fee);\n        _tokenLiquidity.ethPool -= _ethToSwap;\n        _tokenLiquidity.tokenPool += _tokenQuantity;\n        tokenLiquidity[_tokenAddress] = _tokenLiquidity;\n    }\n\n    function swapEthToToken(address _tokenAddress) external payable {\n        require(tokenPoolOwner[_tokenAddress] != address(0), \"Token is not created.\");\n        uint _tokenValue = getTokenValue(_tokenAddress);\n        TokenLiquidity memory _tokenLiquidity = tokenLiquidity[_tokenAddress];\n        uint dec = 10 ** 18;\n        uint _tokensToSwap = msg.value * dec / _tokenValue;\n        require(_tokensToSwap <= _tokenLiquidity.tokenPool, \"Exceeds the liquidity balance\");\n        uint fee =_tokensToSwap * DEX_FEE / 1000;\n        IERC20(_tokenAddress).transfer(msg.sender, _tokensToSwap - fee);\n        IERC20(_tokenAddress).transfer(DEX_FEE_DESTINATION_ADDRESS, fee);\n        _tokenLiquidity.ethPool += msg.value;\n        _tokenLiquidity.tokenPool -= _tokensToSwap;\n        tokenLiquidity[_tokenAddress] = _tokenLiquidity;\n    }\n\n    function swapTokenToToken(address _tokenAddressFrom, address _tokenAddressTo, uint _tokenQuantity) external {\n        require(tokenPoolOwner[_tokenAddressFrom] != address(0), \"Token is not created.\");\n        require(tokenPoolOwner[_tokenAddressTo] != address(0), \"Token is not created.\");\n        uint _tokenValueInToken = getTokenValueInOtherToken(_tokenAddressFrom, _tokenAddressTo);\n        uint _tokenValueInEth = getTokenValue(_tokenAddressFrom);\n        TokenLiquidity memory _tokenFromLiquidity = tokenLiquidity[_tokenAddressFrom];\n        TokenLiquidity memory _tokenToLiquidity = tokenLiquidity[_tokenAddressTo];\n        uint dec = 10 ** 18;\n        uint _tokensToSwap = _tokenQuantity * _tokenValueInToken / dec;\n        uint _ethsToMove = _tokenQuantity * _tokenValueInEth / dec;\n        require(_tokensToSwap <= _tokenToLiquidity.tokenPool, \"Exceeds the liquidity balance\");\n        require(_ethsToMove <= _tokenFromLiquidity.ethPool, \"Exceeds the liquidity balance\");\n        require(IERC20(_tokenAddressFrom).transferFrom(msg.sender, address(this), _tokenQuantity), \"Failed transfer from token.\");\n        uint fee = _tokensToSwap * DEX_FEE / 1000;\n        IERC20(_tokenAddressTo).transfer(msg.sender, _tokensToSwap - fee);\n        IERC20(_tokenAddressTo).transfer(DEX_FEE_DESTINATION_ADDRESS, fee);\n        _tokenFromLiquidity.ethPool -= _ethsToMove;\n        _tokenFromLiquidity.tokenPool += _tokenQuantity;\n        _tokenToLiquidity.ethPool += _ethsToMove;\n        _tokenToLiquidity.tokenPool -= _tokensToSwap;\n        tokenLiquidity[_tokenAddressFrom] = _tokenFromLiquidity;\n        tokenLiquidity[_tokenAddressTo] = _tokenToLiquidity;\n    }\n\n    function getTokenValue(address _tokenAddress) public view returns(uint) {\n        uint dec = 10 ** 18;\n        return tokenLiquidity[_tokenAddress].ethPool * dec / tokenLiquidity[_tokenAddress].tokenPool;\n    }\n\n    function getTokenValueInOtherToken(address _tokenAddressFrom, address _tokenAddressTo) public view returns(uint) {\n        uint dec = 10 ** 18;\n        return getTokenValue(_tokenAddressFrom) * dec / getTokenValue(_tokenAddressTo);\n    }\n\n    function getAddressPools(address _owner) public view returns(address[] memory) {\n        return ownerTokenPools[_owner];\n    }\n\n    function getTokens() public view returns(address[] memory) {\n        return tokens;\n    }\n\n    function setDexFee(uint _fee) external onlyOwner {\n        DEX_FEE = _fee;\n    }\n\n    function setDexFeeDestinationAddress(address _address) external onlyOwner {\n        DEX_FEE_DESTINATION_ADDRESS = _address;\n    }\n\n}"
        },
        "contracts/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IERC20 {\n    function transferFrom(\n        address from, \n        address to, \n        uint256 value\n    ) external returns (bool);\n    function transfer(\n        address to, \n        uint256 value\n    ) external returns (bool);\n}"
        },
        "@openzeppelin/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        },
        "remappings": []
    }
}